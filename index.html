<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>CYBER ARENA - Enhanced Edition</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body{
    background:#000; height:100vh; display:flex; align-items:center; justify-content:center;
    overflow:hidden; font-family:"Courier New", monospace;
  }
  #game-container { position:relative; }
  canvas { display:block; border:1px solid #0ff3; }
</style>
</head>
<body>
<div id="game-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
<script>
// ============================================================
// CYBER ARENA â€” ENHANCED EDITION
// With Persistence, Achievements, New Weapons, Enemy Types, Boss Variety & Ship Perks
// ============================================================
const W = 900, H = 680;
let highScore = 0, lastScore = 0, lastWave = 0, lastStats = {}, selectedShip = 0;

// ============================================================
// PERSISTENT UPGRADES & ACHIEVEMENTS SYSTEM
// ============================================================
const PERSISTENT_UPGRADES = {
  maxHpBonus: {name: 'Max HP Boost', max: 5, bonus: 20, cost: 100},
  damageBonus: {name: 'Damage Boost', max: 5, bonus: 15, cost: 150},
  speedBonus: {name: 'Speed Boost', max: 5, bonus: 10, cost: 120},
  startingShield: {name: 'Starting Shield', max: 3, bonus: 25, cost: 180}
};

const ACHIEVEMENTS = {
  firstKill: {name: 'First Blood', desc: 'Kill your first enemy', unlocked: false},
  wave5: {name: 'Survivor', desc: 'Reach wave 5', unlocked: false},
  wave10: {name: 'Veteran', desc: 'Reach wave 10', unlocked: false},
  wave20: {name: 'Legend', desc: 'Reach wave 20', unlocked: false},
  boss1: {name: 'Boss Slayer', desc: 'Defeat your first boss', unlocked: false},
  combo10: {name: 'Combo Master', desc: 'Achieve 10x combo', unlocked: false},
  enemies100: {name: 'Exterminator', desc: 'Kill 100 enemies', unlocked: false},
  enemies500: {name: 'Annihilator', desc: 'Kill 500 enemies', unlocked: false},
  noDamageWave: {name: 'Untouchable', desc: 'Complete a wave without taking damage', unlocked: false},
  allUpgrades: {name: 'Fully Loaded', desc: 'Take 10 upgrades in one run', unlocked: false}
};

let persistentUpgrades = {};
let achievements = {};
let totalEnemiesKilled = 0;
let currentGame = null;

function loadPersistent(){ 
  try{ 
    const d=localStorage.getItem('cyberArenaEnhanced'); 
    if(d){ 
      const o=JSON.parse(d); 
      persistentUpgrades=o.persistentUpgrades||{};
      achievements=o.achievements||{};
      totalEnemiesKilled=o.totalEnemiesKilled||0;
      highScore=o.highScore||0;
      selectedShip=o.selectedShip||0;
      Object.keys(ACHIEVEMENTS).forEach(k => {
        if(!achievements[k]) achievements[k] = {...ACHIEVEMENTS[k]};
        else achievements[k] = {...ACHIEVEMENTS[k], ...achievements[k]};
      });
    }
  }catch(e){ console.error('Load error:', e); } 
}

function savePersistent(){ 
  try{ 
    localStorage.setItem('cyberArenaEnhanced',JSON.stringify({
      persistentUpgrades,
      achievements,
      totalEnemiesKilled,
      highScore,
      selectedShip
    })); 
  }catch(e){ console.error('Save error:', e); } 
}

function unlockAchievement(key) {
  if(!achievements[key]) achievements[key] = {...ACHIEVEMENTS[key]};
  if(!achievements[key].unlocked) {
    achievements[key].unlocked = true;
    savePersistent();
    if(currentGame && currentGame.showNotif) {
      currentGame.showNotif('ðŸ† ' + achievements[key].name, '#ffaa00', 2.5);
      if(window.sfx) sfx('upgrade');
    }
    console.log('Achievement unlocked:', achievements[key].name);
  }
}

function applyPersistentBonuses(ship) {
  const hpBonus = (persistentUpgrades.maxHpBonus || 0) * PERSISTENT_UPGRADES.maxHpBonus.bonus;
  const speedMult = 1 + ((persistentUpgrades.speedBonus || 0) * PERSISTENT_UPGRADES.speedBonus.bonus / 100);
  const damageMult = 1 + ((persistentUpgrades.damageBonus || 0) * PERSISTENT_UPGRADES.damageBonus.bonus / 100);
  const shieldBonus = (persistentUpgrades.startingShield || 0) * PERSISTENT_UPGRADES.startingShield.bonus;
  
  return {
    hp: ship.baseHp + hpBonus,
    maxHp: ship.baseHp + hpBonus,
    speed: ship.baseSpeed * speedMult,
    baseDmg: ship.baseDmg * damageMult,
    shield: shieldBonus,
    maxShield: shieldBonus
  };
}

function trackEnemyKill() {
  totalEnemiesKilled++;
  
  if(totalEnemiesKilled === 1) unlockAchievement('firstKill');
  if(totalEnemiesKilled === 100) unlockAchievement('enemies100');
  if(totalEnemiesKilled === 500) unlockAchievement('enemies500');
  
  savePersistent();
}

loadPersistent();

const SHIPS = [
  { 
    name:'VIPER',  
    color:0x00ffff, 
    glow:0x44ffff, 
    desc:'Balanced fighter',      
    baseHp:100, 
    baseSpeed:240, 
    baseDmg:25, 
    baseRate:140, 
    dashCD:0.75, 
    col2:'#00ffff', 
    stats:{firepower:75,speed:80,defense:65,mobility:85},
    perk: 'RAPID STRIKE',
    perkDesc: 'Every 5th shot fires instantly',
    perkColor: '#00ffff'
  },
  { 
    name:'TANKS',  
    color:0x7733ff, 
    glow:0x9955ff, 
    desc:'Heavy â€” slow & sturdy', 
    baseHp:150, 
    baseSpeed:185, 
    baseDmg:20, 
    baseRate:165, 
    dashCD:0.90, 
    col2:'#7733ff', 
    stats:{firepower:60,speed:50,defense:95,mobility:45},
    perk: 'ARMOR PLATING',
    perkDesc: 'Reduce damage taken by 25%',
    perkColor: '#7733ff'
  },
  { 
    name:'RAZOR',  
    color:0xff6600, 
    glow:0xff8844, 
    desc:'Fast â€” glass cannon',  
    baseHp:70,  
    baseSpeed:310, 
    baseDmg:32, 
    baseRate:110, 
    dashCD:0.55, 
    col2:'#ff6600', 
    stats:{firepower:95,speed:100,defense:35,mobility:90},
    perk: 'AFTERBURNER',
    perkDesc: 'Move 15% faster after dashing',
    perkColor: '#ff6600'
  },
];

// ============================================================
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const randI=(a,b)=>(a+(Math.random()*(b-a+1)|0));
const dist2=(x1,y1,x2,y2)=>{let dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy;};
const dist=(x1,y1,x2,y2)=>Math.sqrt(dist2(x1,y1,x2,y2));
const norm=(x,y)=>{const l=Math.sqrt(x*x+y*y);return l>0?[x/l,y/l]:[0,0];};
const angDiff=(a,b)=>{let d=a-b;while(d>Math.PI)d-=Math.PI*2;while(d<-Math.PI)d+=Math.PI*2;return d;};

// ============================================================
// SHIP DRAWING FUNCTIONS
// ============================================================
function drawShipPreview(g, shipType, x, y, angle, color, size=0.85) {
  const s = 16 * size;
  
  if(shipType === 'VIPER') {
    g.fillStyle(0x0a0a2a, 1);
    g.beginPath();
    g.moveTo(x, y - s);
    g.lineTo(x + s * 0.5, y + s * 0.3);
    g.lineTo(x + s * 0.35, y + s * 0.6);
    g.lineTo(x - s * 0.35, y + s * 0.6);
    g.lineTo(x - s * 0.5, y + s * 0.3);
    g.closePath();
    g.fillPath();
    
    g.lineStyle(2, color, 0.85);
    g.strokePath();
    
    g.fillStyle(color, 0.9);
    g.beginPath();
    g.arc(x, y - s * 0.4, 3 * size, 0, Math.PI * 2);
    g.fillPath();
  } 
  else if(shipType === 'TANKS') {
    g.fillStyle(0x0a0a2a, 1);
    g.beginPath();
    for(let i = 0; i < 6; i++) {
      const ang = (i / 6) * Math.PI * 2 - Math.PI / 2;
      const px = x + Math.cos(ang) * s * 0.7;
      const py = y + Math.sin(ang) * s * 0.7;
      if(i === 0) g.moveTo(px, py);
      else g.lineTo(px, py);
    }
    g.closePath();
    g.fillPath();
    
    g.lineStyle(2.5, color, 0.85);
    g.strokePath();
    
    g.fillStyle(color, 0.3);
    g.beginPath();
    for(let i = 0; i < 6; i++) {
      const ang = (i / 6) * Math.PI * 2;
      g.lineTo(x + Math.cos(ang) * s * 0.35, y + Math.sin(ang) * s * 0.35);
    }
    g.closePath();
    g.fillPath();
  }
  else if(shipType === 'RAZOR') {
    g.fillStyle(0x0a0a2a, 1);
    g.beginPath();
    g.moveTo(x, y - s * 1.1);
    g.lineTo(x + s * 0.35, y + s * 0.5);
    g.lineTo(x, y + s * 0.3);
    g.lineTo(x - s * 0.35, y + s * 0.5);
    g.closePath();
    g.fillPath();
    
    g.lineStyle(1.8, color, 0.9);
    g.strokePath();
    
    g.fillStyle(color, 0.9);
    g.fillRect(x - s * 0.08, y - s * 0.5, s * 0.16, s * 0.7);
  }
}

function drawShipInGame(g, shipType, x, y, angle, color, stage = 0) {
  const s = 18;
  const ca = Math.cos(angle);
  const sa = Math.sin(angle);
  
  if(shipType === 'VIPER') {
    // Core body
    g.fillStyle(0x0a0a2a, 1);
    g.beginPath();
    g.moveTo(x + ca * s, y + sa * s);
    g.lineTo(x + ca * (-s * 0.4) + sa * (s * 0.5), y + sa * (-s * 0.4) - ca * (s * 0.5));
    g.lineTo(x + ca * (-s * 0.6) + sa * (s * 0.35), y + sa * (-s * 0.6) - ca * (s * 0.35));
    g.lineTo(x + ca * (-s * 0.6) - sa * (s * 0.35), y + sa * (-s * 0.6) + ca * (s * 0.35));
    g.lineTo(x + ca * (-s * 0.4) - sa * (s * 0.5), y + sa * (-s * 0.4) + ca * (s * 0.5));
    g.closePath();
    g.fillPath();
    
    g.lineStyle(2, color, 0.85);
    g.strokePath();
    
    // Cockpit
    g.fillStyle(color, 0.9);
    g.beginPath();
    g.arc(x + ca * (s * 0.4), y + sa * (s * 0.4), 3.5, 0, Math.PI * 2);
    g.fillPath();
    
    // Stage upgrades
    if(stage >= 1) {
      // Wing boosters
      g.fillStyle(0xff8800, 0.6);
      g.fillRect(x + ca * (-s * 0.5) + sa * (s * 0.4) - 2, y + sa * (-s * 0.5) - ca * (s * 0.4) - 2, 4, 4);
      g.fillRect(x + ca * (-s * 0.5) - sa * (s * 0.4) - 2, y + sa * (-s * 0.5) + ca * (s * 0.4) - 2, 4, 4);
    }
    
    if(stage >= 2) {
      // Ultimate: Energy trails
      g.lineStyle(1.5, 0x00ffff, 0.5);
      g.strokePath();
    }
  } 
  else if(shipType === 'TANKS') {
    g.fillStyle(0x0a0a2a, 1);
    g.beginPath();
    for(let i = 0; i < 6; i++) {
      const ang = angle + (i / 6) * Math.PI * 2;
      const px = x + Math.cos(ang) * s * 0.75;
      const py = y + Math.sin(ang) * s * 0.75;
      if(i === 0) g.moveTo(px, py);
      else g.lineTo(px, py);
    }
    g.closePath();
    g.fillPath();
    
    g.lineStyle(2.5, color, 0.85);
    g.strokePath();
    
    g.fillStyle(color, 0.35);
    g.beginPath();
    for(let i = 0; i < 6; i++) {
      const ang = angle + (i / 6) * Math.PI * 2 + Math.PI / 6;
      g.lineTo(x + Math.cos(ang) * s * 0.4, y + Math.sin(ang) * s * 0.4);
    }
    g.closePath();
    g.fillPath();
    
    // Stage upgrades
    if(stage >= 1) {
      // Armor panels
      g.lineStyle(2, color, 0.9);
      g.beginPath();
      g.arc(x, y, s * 0.9, 0, Math.PI * 2);
      g.strokePath();
    }
    
    if(stage >= 2) {
      // Ultimate: Turrets
      for(let i = 0; i < 4; i++) {
        const ang = angle + (i / 4) * Math.PI * 2;
        g.fillStyle(0xff4444, 0.7);
        g.fillRect(x + Math.cos(ang) * s * 0.8 - 2, y + Math.sin(ang) * s * 0.8 - 2, 4, 4);
      }
    }
  }
  else if(shipType === 'RAZOR') {
    g.fillStyle(0x0a0a2a, 1);
    g.beginPath();
    g.moveTo(x + ca * (s * 1.15), y + sa * (s * 1.15));
    g.lineTo(x + ca * (-s * 0.5) + sa * (s * 0.45), y + sa * (-s * 0.5) - ca * (s * 0.45));
    g.lineTo(x + ca * (-s * 0.3), y + sa * (-s * 0.3));
    g.lineTo(x + ca * (-s * 0.5) - sa * (s * 0.45), y + sa * (-s * 0.5) + ca * (s * 0.45));
    g.closePath();
    g.fillPath();
    
    g.lineStyle(2, color, 0.9);
    g.strokePath();
    
    g.fillStyle(color, 0.9);
    g.fillRect(x + ca * (s * 0.2) - 2.5, y + sa * (s * 0.2) - 6, 5, 12);
    
    // Stage upgrades
    if(stage >= 1) {
      // Afterburners
      g.fillStyle(0xff6600, 0.7);
      g.fillRect(x + ca * (-s * 0.4) + sa * (s * 0.3) - 2, y + sa * (-s * 0.4) - ca * (s * 0.3) - 2, 4, 4);
      g.fillRect(x + ca * (-s * 0.4) - sa * (s * 0.3) - 2, y + sa * (-s * 0.4) + ca * (s * 0.3) - 2, 4, 4);
    }
    
    if(stage >= 2) {
      // Ultimate: Blades
      g.lineStyle(1.5, color, 0.8);
      g.beginPath();
      g.moveTo(x + ca * (s * 1.2) + sa * (s * 0.5), y + sa * (s * 1.2) - ca * (s * 0.5));
      g.lineTo(x + ca * (s * 0.8) + sa * (s * 0.7), y + sa * (s * 0.8) - ca * (s * 0.7));
      g.strokePath();
      
      g.beginPath();
      g.moveTo(x + ca * (s * 1.2) - sa * (s * 0.5), y + sa * (s * 1.2) + ca * (s * 0.5));
      g.lineTo(x + ca * (s * 0.8) - sa * (s * 0.7), y + sa * (s * 0.8) + ca * (s * 0.7));
      g.strokePath();
    }
  }
}

// ============================================================
// AUDIO
// ============================================================
let audioCtx = null;

function initAudio() {
  if(!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    console.log('Audio initialized');
  }
}

function beep(freq, type, vol, dur, delay = 0) {
  if(!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime + delay);
  gain.gain.setValueAtTime(vol, audioCtx.currentTime + delay);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + dur);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(audioCtx.currentTime + delay);
  osc.stop(audioCtx.currentTime + delay + dur);
}

function sfx(name) {
  if(!audioCtx) return;
  switch(name) {
    case 'shoot': beep(280, 'square', 0.05, 0.05); beep(320, 'square', 0.03, 0.06, 0.01); break;
    case 'hit': beep(150, 'sawtooth', 0.10, 0.08); beep(80, 'sawtooth', 0.06, 0.10, 0.02); break;
    case 'enemyHit': beep(200, 'triangle', 0.06, 0.05); beep(120, 'triangle', 0.04, 0.07, 0.01); break;
    case 'enemyDie': beep(180, 'sawtooth', 0.12, 0.15); beep(90, 'sawtooth', 0.08, 0.20, 0.05); break;
    case 'dash': beep(600, 'sine', 0.08, 0.12); beep(800, 'sine', 0.06, 0.15, 0.03); break;
    case 'pickup': beep(440, 'sine', 0.08, 0.10); beep(660, 'sine', 0.08, 0.12, 0.08); beep(880, 'sine', 0.06, 0.10, 0.16); break;
    case 'upgrade': beep(440, 'triangle', 0.10, 0.15); beep(660, 'triangle', 0.10, 0.15, 0.08); beep(880, 'triangle', 0.08, 0.15, 0.16); break;
    case 'slowmo': beep(60, 'sine', 0.08, 0.35); beep(40, 'sine', 0.06, 0.50, 0.15); break;
    case 'bossDie': beep(100, 'sawtooth', 0.15, 0.40); beep(60, 'sawtooth', 0.12, 0.60, 0.15); beep(40, 'sawtooth', 0.10, 0.80, 0.30); break;
    case 'bossBegin': beep(200, 'square', 0.12, 0.25); beep(150, 'square', 0.12, 0.25, 0.12); beep(100, 'square', 0.12, 0.30, 0.24); break;
    case 'playerDie': beep(220, 'sawtooth', 0.12, 0.30); beep(110, 'sawtooth', 0.10, 0.50, 0.15); beep(55, 'sawtooth', 0.08, 0.70, 0.30); break;
    case 'shieldHit': beep(500, 'sine', 0.08, 0.08); beep(400, 'sine', 0.06, 0.10, 0.02); break;
    case 'laser': beep(800,'sine',0.05,0.15); beep(1200,'sine',0.03,0.20,0.02); break;
    case 'shotgun': beep(120,'square',0.08,0.08); beep(80,'square',0.05,0.10,0.01); break;
    case 'ricochet': beep(400,'triangle',0.05,0.05); beep(600,'triangle',0.03,0.06,0.02); break;
    case 'gravityWell': beep(60,'sine',0.06,0.30); beep(40,'sine',0.04,0.40,0.10); break;
    case 'teleport': beep(800,'sine',0.07,0.08); beep(400,'sine',0.05,0.10,0.03); break;
  }
}

// ============================================================
// MENU SCENE
// ============================================================
class MenuScene extends Phaser.Scene {
  constructor() { super('Menu'); }

  create() {
    this.cameras.main.setBackgroundColor('#000000');
    
    // Grid background
    this.gBg = this.add.graphics();
    this.gBg.lineStyle(1, 0x00ffff, 0.15);
    for(let x = 0; x <= W; x += 40) {
      this.gBg.lineTo(x, 0);
      this.gBg.lineTo(x, H);
      this.gBg.moveTo(x + 40, 0);
    }
    for(let y = 0; y <= H; y += 40) {
      this.gBg.moveTo(0, y);
      this.gBg.lineTo(W, y);
    }
    this.gBg.strokePath();
    
    // Title
    this.add.text(W / 2, 90, 'CYBER ARENA', {
      fontSize: '64px',
      fontFamily: '"Courier New"',
      color: '#00ffff'
    }).setOrigin(0.5).setDepth(10);
    
    this.add.text(W / 2, 135, 'ENHANCED EDITION', {
      fontSize: '16px',
      fontFamily: '"Courier New"',
      color: '#66ffff'
    }).setOrigin(0.5).setDepth(10).setAlpha(0.8);
    
    // High score
    this.add.text(W / 2, 175, `HIGH SCORE: ${highScore}`, {
      fontSize: '14px',
      fontFamily: '"Courier New"',
      color: '#ffaa00'
    }).setOrigin(0.5).setDepth(10);
    
    // Ship selection
    this.add.text(W / 2, 230, 'SELECT YOUR SHIP', {
      fontSize: '20px',
      fontFamily: '"Courier New"',
      color: '#ffffff'
    }).setOrigin(0.5).setDepth(10);
    
    this.shipGraphics = [];
    SHIPS.forEach((s, i) => {
      const cx = 200 + i * 250;
      const cy = 345;
      const g = this.add.graphics().setDepth(11);
      
      // Selection highlight
      if(i === selectedShip) {
        g.lineStyle(3, Phaser.Display.Color.ValueToColor(s.color).color, 0.8);
        g.strokeRect(cx - 95, cy - 125, 190, 260);
      }
      
      // Ship preview
      drawShipPreview(g, s.name, cx, cy - 40, 0, s.color, 1.2);
      
      // Ship name
      this.add.text(cx, cy + 50, s.name, {
        fontSize: '18px',
        fontFamily: '"Courier New"',
        color: s.col2
      }).setOrigin(0.5).setDepth(12);
      
      // Description
      this.add.text(cx, cy + 72, s.desc, {
        fontSize: '11px',
        fontFamily: '"Courier New"',
        color: '#889999'
      }).setOrigin(0.5).setDepth(12).setAlpha(0.85);
      
      // Stats bars
      const stats = ['firepower', 'speed', 'defense', 'mobility'];
      const statNames = ['FIRE', 'SPEED', 'DEF', 'MOB'];
      stats.forEach((stat, si) => {
        const sy = cy + 95 + si * 16;
        const val = s.stats[stat];
        
        this.add.text(cx - 75, sy, statNames[si], {
          fontSize: '8px',
          fontFamily: '"Courier New"',
          color: '#667788'
        }).setDepth(12);
        
        const barG = this.add.graphics().setDepth(12);
        barG.fillStyle(0x223344, 0.5);
        barG.fillRect(cx - 32, sy - 4, 100, 10);
        barG.fillStyle(Phaser.Display.Color.ValueToColor(s.color).color, 0.8);
        barG.fillRect(cx - 32, sy - 4, val, 10);
      });
      
      // Ship perk
      this.add.text(cx, cy + 170, s.perk, {
        fontSize: '10px',
        fontFamily: '"Courier New"',
        color: s.perkColor
      }).setOrigin(0.5).setDepth(12).setAlpha(0.9);
      
      this.add.text(cx, cy + 183, s.perkDesc, {
        fontSize: '8px',
        fontFamily: '"Courier New"',
        color: '#889999',
        wordWrap: {width: 160}
      }).setOrigin(0.5).setDepth(12).setAlpha(0.7);
      
      // Click zone
      const zone = this.add.zone(cx, cy, 190, 260).setInteractive();
      zone.on('pointerdown', () => {
        selectedShip = i;
        savePersistent();
        this.scene.restart();
      });
      
      this.shipGraphics.push(g);
    });
    
    // Achievements button
    const achBtn = this.add.text(W / 2 - 110, H - 80, 'ðŸ† ACHIEVEMENTS', {
      fontSize: '14px',
      fontFamily: '"Courier New"',
      color: '#ffaa00'
    }).setOrigin(0.5).setDepth(12).setInteractive();
    achBtn.on('pointerdown', () => this.scene.start('Achievements'));
    
    // Start button
    const startBtn = this.add.text(W / 2 + 110, H - 80, 'â–¶ START GAME', {
      fontSize: '14px',
      fontFamily: '"Courier New"',
      color: '#00ff00'
    }).setOrigin(0.5).setDepth(12).setInteractive();
    startBtn.on('pointerdown', () => {
      if(!audioCtx) initAudio();
      this.scene.start('Game');
    });
    
    // Version
    this.add.text(W / 2, H - 30, 'v2.0 Enhanced | Total Enemies Killed: ' + totalEnemiesKilled, {
      fontSize: '10px',
      fontFamily: '"Courier New"',
      color: '#445566'
    }).setOrigin(0.5).setDepth(10);
  }
}

// ============================================================
// ACHIEVEMENTS SCENE
// ============================================================
class AchievementsScene extends Phaser.Scene {
  constructor() { super('Achievements'); }

  create() {
    this.cameras.main.setBackgroundColor('#000000');
    
    this.add.text(W / 2, 60, 'ACHIEVEMENTS', {
      fontSize: '36px',
      fontFamily: '"Courier New"',
      color: '#ffaa00'
    }).setOrigin(0.5);
    
    const achKeys = Object.keys(achievements);
    const unlockedCount = achKeys.filter(k => achievements[k].unlocked).length;
    
    this.add.text(W / 2, 105, `${unlockedCount} / ${achKeys.length} Unlocked`, {
      fontSize: '14px',
      fontFamily: '"Courier New"',
      color: '#66ffff'
    }).setOrigin(0.5);
    
    // Achievement list
    let y = 160;
    achKeys.forEach((key, i) => {
      const ach = achievements[key];
      const unlocked = ach.unlocked;
      
      const bg = this.add.graphics();
      bg.fillStyle(unlocked ? 0x003344 : 0x1a1a1a, 0.5);
      bg.fillRect(150, y - 22, 600, 50);
      
      const icon = this.add.text(170, y, unlocked ? 'ðŸ†' : 'ðŸ”’', {
        fontSize: '24px'
      });
      
      this.add.text(220, y - 12, ach.name, {
        fontSize: '16px',
        fontFamily: '"Courier New"',
        color: unlocked ? '#ffaa00' : '#555555'
      });
      
      this.add.text(220, y + 8, ach.desc, {
        fontSize: '12px',
        fontFamily: '"Courier New"',
        color: unlocked ? '#aaccff' : '#444444'
      });
      
      y += 58;
    });
    
    // Back button
    const backBtn = this.add.text(W / 2, H - 60, 'â† BACK', {
      fontSize: '16px',
      fontFamily: '"Courier New"',
      color: '#00ffff'
    }).setOrigin(0.5).setInteractive();
    backBtn.on('pointerdown', () => this.scene.start('Menu'));
  }
}

// ============================================================
// GAME SCENE
// ============================================================
class GameScene extends Phaser.Scene {
  constructor(){ super('Game'); }

  create(){
    currentGame = this;
    
    this.gBg=this.add.graphics().setDepth(0);
    this.gVig=this.add.graphics().setDepth(1);
    this.gPk=this.add.graphics().setDepth(3);
    this.gEn=this.add.graphics().setDepth(5);
    this.gBu=this.add.graphics().setDepth(7);
    this.gPa=this.add.graphics().setDepth(9);
    this.gPl=this.add.graphics().setDepth(10);
    this.gHu=this.add.graphics().setDepth(20);
    this.gUp=this.add.graphics().setDepth(30);
    this.gSlow=this.add.graphics().setDepth(31);

    this.score=0; this.wave=0; this.gameOver=false;
    this.enemies=[]; this.bullets=[]; this.eBullets=[];
    this.particles=[]; this.pickups=[]; this.sniperWarnings=[];
    this.gravityWells=[];
    this.spawnQ=[]; this.spawnT=0; this.spawnDelay=280;
    this.waveComplete=false; this.waveEndT=0; this.isBossWave=false; this.isMiniBossWave=false;
    this.shakeT=0; this.shakeAmt=0; this.gridOff=0;
    this.mouseDown=false; this.lastFired=0;
    this.slowT=0; this.slowActive=false; this.bossKillSlowT=0;
    this.combo=0; this.comboTimer=0; this.comboMaxTime=1.8;
    this.muzzleFlashT=0;
    this.stats={enemiesKilled:0,upgradesTaken:0,dashesUsed:0,peakCombo:0};
    this.upgradeMode=false; this.upgradeButtons=[]; this.upgradeTexts=[];
    this.upTitle=null; this.upSub=null; this.upgradeAnimT=0;
    this.waveMsg=null; this.notifText=null; this.notifTimer=0;
    this._dashUp=false;
    this.waveDamageTaken=0;
    this.rapidStrikeCount=0;
    this.afterburnerT=0;
    this.laserBeam=null; this.laserChargeT=0; this.laserActive=false;
    this.bossesDefeated=0;

    const ship=SHIPS[selectedShip];
    const bonuses = applyPersistentBonuses(ship);
    this.p={
      x:W/2,
      y:H/2,
      angle:0,
      hp:bonuses.hp,
      maxHp:bonuses.maxHp,
      shield:bonuses.shield,
      maxShield:bonuses.maxShield,
      speed:bonuses.speed,
      invuln:0,
      dashCD:0,
      dashing:false,
      dashT:0,
      dashA:0,
      shipIdx:selectedShip,
      idleT:0,
      upgradeStage:0,
      hasTeleport:false
    };
    this.w={
      type:'single',
      rate:ship.baseRate,
      dmg:bonuses.baseDmg,
      spd:580,
      pierce:false,
      homing:false,
      mega:false,
      shots:0,
      ricochet:false,
      ricochetsLeft:2,
      shotgun:false,
      laser:false,
      bulletSize:1.0
    };
    this.dashCdDur=ship.dashCD; 
    this.regenRate=0;

    this.tScore=this.add.text(16,16,'',{fontSize:'18px',fontFamily:'"Courier New"',color:'#0ff'}).setDepth(21);
    this.tWave=this.add.text(W-16,16,'',{fontSize:'18px',fontFamily:'"Courier New"',color:'#0ff'}).setOrigin(1,0).setDepth(21);
    this.tHp=this.add.text(16,H-28,'',{fontSize:'13px',fontFamily:'"Courier New"',color:'#f44'}).setDepth(21);
    this.tEnemyCount=this.add.text(W-16,H-22,'',{fontSize:'12px',fontFamily:'"Courier New"',color:'#66ffff'}).setOrigin(1,1).setDepth(21);
    this.comboText=this.add.text(W/2,H/2-140,'',{fontSize:'28px',fontFamily:'"Courier New"',color:'#ffaa00'}).setOrigin(0.5).setDepth(22).setAlpha(0);

    this.keys=this.input.keyboard.addKeys({w:Phaser.Input.Keyboard.KeyCodes.W,a:Phaser.Input.Keyboard.KeyCodes.A,s:Phaser.Input.Keyboard.KeyCodes.S,d:Phaser.Input.Keyboard.KeyCodes.D,space:Phaser.Input.Keyboard.KeyCodes.SPACE});
    this.input.on('pointerdown',(ptr)=>{ this.mouseDown=true; if(!audioCtx)initAudio(); if(this.upgradeMode)this.clickUpgrade(ptr.x,ptr.y); });
    this.input.on('pointerup',()=>this.mouseDown=false);
    this.nextWave();
  }

  showNotif(txt,col='#00ffff',dur=1.2){
    if(!this.notifText) this.notifText=this.add.text(W/2,90,'',{fontSize:'18px',fontFamily:'"Courier New"',color:col}).setOrigin(0.5).setDepth(23);
    this.notifText.setText(txt).setColor(col).setAlpha(1); this.notifTimer=dur;
  }

  nextWave(){
    // Check for no damage achievement
    if(this.wave > 0 && this.waveDamageTaken === 0) {
      unlockAchievement('noDamageWave');
    }
    this.waveDamageTaken = 0;
    
    this.wave++; this.waveComplete=false; this.waveEndT=0;
    
    // Wave achievements
    if(this.wave === 5) unlockAchievement('wave5');
    if(this.wave === 10) unlockAchievement('wave10');
    if(this.wave === 20) unlockAchievement('wave20');
    
    // Ship visual upgrades at specific waves
    const prevStage = this.p.upgradeStage;
    if(this.wave >= 15) this.p.upgradeStage = 2;
    else if(this.wave >= 10) this.p.upgradeStage = 1;
    else if(this.wave >= 5) this.p.upgradeStage = 1;
    else this.p.upgradeStage = 0;
    
    if(this.p.upgradeStage > prevStage){
      const stageName = this.p.upgradeStage === 1 ? 'ENHANCED' : 'ULTIMATE';
      this.showNotif('â¬† SHIP UPGRADED: ' + stageName, '#00ffff', 2.5);
      sfx('upgrade');
      this.burst(this.p.x, this.p.y, SHIPS[this.p.shipIdx].color, 30, 150);
    }
    
    this.isBossWave=(this.wave%5===0); 
    this.isMiniBossWave=(this.wave%3===0 && !this.isBossWave);
    this.spawnQ=[];
    
    if(this.isBossWave){
      const bossType = ['boss', 'boss2', 'boss3'][randI(0,2)];
      this.spawnQ.push(bossType); 
      this.spawnDelay=0; 
      sfx('bossBegin');
      this.showWaveMsg('â€” BOSS â€”','#ff4444',1.4);
    } else if(this.isMiniBossWave) {
      this.spawnQ.push('miniboss');
      const extras = Math.min(5 + this.wave, 20) | 0;
      for(let i=0; i<extras; i++) {
        const r=Math.random();
        if(this.wave<=4) this.spawnQ.push('drone');
        else if(this.wave<=7) this.spawnQ.push(r<0.5?'drone':'scout');
        else this.spawnQ.push(r<0.3?'drone':r<0.6?'scout':'tank');
      }
      this.spawnDelay=280;
      this.showWaveMsg('âš¡ MINI-BOSS âš¡','#ffaa00',1.2);
    } else {
      const count=Math.min(6+this.wave*2.5,45)|0;
      for(let i=0;i<count;i++){
        const r=Math.random();
        if(this.wave<=2) this.spawnQ.push('drone');
        else if(this.wave<=4) this.spawnQ.push(r<0.6?'drone':'scout');
        else if(this.wave<=7) this.spawnQ.push(r<0.30?'drone':r<0.55?'scout':r<0.70?'tank':r<0.85?'healer':'bomber');
        else if(this.wave<=10) this.spawnQ.push(r<0.20?'drone':r<0.40?'scout':r<0.55?'tank':r<0.65?'shieldE':r<0.75?'sniper':r<0.85?'healer':r<0.92?'spawner':'teleporter');
        else this.spawnQ.push(r<0.12?'drone':r<0.28?'scout':r<0.43?'tank':r<0.55?'shieldE':r<0.65?'sniper':r<0.74?'swarm':r<0.82?'healer':r<0.88?'spawner':r<0.93?'bomber':r<0.96?'teleporter':r<0.98?'kamikaze':'artillery');
      }
      this.spawnDelay=280;
      this.showWaveMsg('WAVE '+this.wave,'#00ffff',1.0);
    }
    this.spawnT=0;
  }

  showWaveMsg(txt,col,dur){
    if(this.waveMsg) this.waveMsg.destroy();
    this.waveMsg=this.add.text(W/2,H/2-80,txt,{fontSize:'34px',fontFamily:'"Courier New"',color:col}).setOrigin(0.5).setDepth(25);
    this.time.delayedCall(dur*1000,()=>{ if(this.waveMsg) this.waveMsg.setVisible(false); });
  }

  spawnEnemy(type){
    const side=randI(0,3); let x,y;
    if(side===0){x=rand(0,W);y=-40;} else if(side===1){x=rand(0,W);y=H+40;} else if(side===2){x=-40;y=rand(0,H);} else{x=W+40;y=rand(0,H);}
    const e={x,y,angle:0,type,alive:true};
    
    switch(type){
      case 'drone': e.hp=30+this.wave*8;e.speed=90+this.wave*3;e.size=14;e.color=0xff3333;e.glow=0xff5555;e.pts=10+this.wave*2; break;
      case 'scout': e.hp=18+this.wave*4;e.speed=155+this.wave*4;e.size=9;e.color=0xffaa00;e.glow=0xffcc44;e.pts=15+this.wave*2; break;
      case 'tank': e.hp=120+this.wave*22;e.speed=52+this.wave;e.size=26;e.color=0x7733ff;e.glow=0x9955ff;e.pts=35+this.wave*3; break;
      case 'shieldE': e.hp=55+this.wave*10;e.speed=48+this.wave;e.size=20;e.color=0x33ccff;e.glow=0x55eeff;e.pts=25+this.wave*2;e.shieldA=0; break;
      case 'sniper': e.hp=40+this.wave*7;e.speed=55+this.wave*2;e.size=12;e.color=0xff2222;e.glow=0xff5555;e.pts=30+this.wave*3;e.shootT=2.0;e.chargeT=0;e.charging=false;e.chargeTarget=null;e.minRange=180; break;
      case 'swarm': e.hp=70+this.wave*12;e.speed=75+this.wave*3;e.size=18;e.color=0x44ff88;e.glow=0x66ffaa;e.pts=28+this.wave*3; break;
      
      // New enemy types
      case 'healer': e.hp=50+this.wave*8;e.speed=60+this.wave*2;e.size=16;e.color=0x44ff44;e.glow=0x66ff66;e.pts=30+this.wave*3;e.healT=2.0;e.healRange=120; break;
      case 'spawner': e.hp=80+this.wave*15;e.speed=40+this.wave;e.size=22;e.color=0xff44ff;e.glow=0xff66ff;e.pts=40+this.wave*4;e.spawnT=4.0;e.maxSpawns=3;e.spawned=0; break;
      case 'bomber': e.hp=35+this.wave*6;e.speed=70+this.wave*2;e.size=14;e.color=0xff8800;e.glow=0xffaa44;e.pts=25+this.wave*2; break;
      case 'teleporter': e.hp=45+this.wave*7;e.speed=80+this.wave*3;e.size=13;e.color=0x8844ff;e.glow=0xaa66ff;e.pts=35+this.wave*3;e.teleportT=2.5; break;
      case 'kamikaze': e.hp=25+this.wave*5;e.speed=180+this.wave*5;e.size=11;e.color=0xff0044;e.glow=0xff4466;e.pts=20+this.wave*2;e.chargeSpeed=280; break;
      case 'artillery': e.hp=60+this.wave*10;e.speed=35+this.wave;e.size=18;e.color=0x6666ff;e.glow=0x8888ff;e.pts=35+this.wave*3;e.shootT=1.8;e.minRange=200; break;
      
      // Bosses
      case 'boss': e.hp=800+this.wave*180;e.speed=55;e.size=40;e.color=0xff2266;e.glow=0xff4488;e.pts=400+this.wave*60;e.x=W/2;e.y=-70;e.phase=1;e.shootT=0;e.charging=false;e.chargeT=0;e.chargeTarget=null;e.chargeI=3.2;e.orbA=0;e.ringA=0;e._enteredArena=false; break;
      case 'boss2': e.hp=900+this.wave*200;e.speed=70;e.size=38;e.color=0x4466ff;e.glow=0x6688ff;e.pts=450+this.wave*65;e.x=W/2;e.y=-70;e.phase=1;e.shootT=0;e.orbitals=[];e.orbitalA=0;e._enteredArena=false; break;
      case 'boss3': e.hp=750+this.wave*160;e.speed=85;e.size=36;e.color=0x44ff44;e.glow=0x66ff66;e.pts=420+this.wave*62;e.x=W/2;e.y=-70;e.phase=1;e.shootT=0;e.splitT=8.0;e._enteredArena=false; break;
      case 'miniboss': e.hp=350+this.wave*80;e.speed=65+this.wave;e.size=32;e.color=0xffaa00;e.glow=0xffcc44;e.pts=200+this.wave*30;e.x=W/2;e.y=-60;e.shootT=0;e.phase=1;e.orbA=0;e._enteredArena=false; break;
    }
    e.maxHp=e.hp; this.enemies.push(e);
  }

  fire(time){
    const ship = SHIPS[this.p.shipIdx];
    const a=this.p.angle, spd=this.w.spd+this.wave*5, dmg=this.w.dmg+this.wave*2;
    
    // VIPER perk: Rapid Strike
    if(ship.name === 'VIPER') {
      this.rapidStrikeCount++;
      if(this.rapidStrikeCount >= 5) {
        this.rapidStrikeCount = 0;
        this.lastFired = time - this.w.rate;
      }
    }
    
    // Shotgun blast
    if(this.w.shotgun) {
      const spreadCount = 8;
      const spreadAngle = 0.6;
      for(let i=0; i<spreadCount; i++) {
        const angle = a - spreadAngle/2 + (i/(spreadCount-1)) * spreadAngle;
        const pelletSpd = spd * 0.7;
        const pelletDmg = dmg * 0.6;
        this.bullets.push({
          x:this.p.x+Math.cos(a)*24,
          y:this.p.y+Math.sin(a)*24,
          angle,
          vx:Math.cos(angle)*pelletSpd,
          vy:Math.sin(angle)*pelletSpd,
          dmg:pelletDmg,
          life:0.8,
          pierce:false,
          homing:false,
          mega:false,
          trail:[],
          shotgun:true,
          size:this.w.bulletSize,
          ricochet:false,
          ricochetsLeft:0
        });
      }
      sfx('shotgun');
      this.burst(this.p.x+Math.cos(a)*26,this.p.y+Math.sin(a)*26,0xffaa00,12,90);
      this.shake(5,0.08);
      return;
    }
    
    // Laser beam
    if(this.w.laser) {
      if(!this.laserActive) {
        this.laserActive = true;
        this.laserChargeT = 0;
        sfx('laser');
      }
      return;
    }
    
    const mk=(ang)=>({
      x:this.p.x+Math.cos(a)*24,
      y:this.p.y+Math.sin(a)*24,
      angle:ang,
      vx:Math.cos(ang)*spd,
      vy:Math.sin(ang)*spd,
      dmg,
      life:1.6,
      pierce:this.w.pierce,
      homing:this.w.homing,
      mega:false,
      trail:[],
      size:this.w.bulletSize,
      ricochet:this.w.ricochet,
      ricochetsLeft:2
    });
    
    this.w.shots++;
    if(this.w.mega&&(this.w.shots%7===0)){
      const b=mk(a); b.mega=true; b.dmg=dmg*3; b.life=2.1; b.vx*=0.78; b.vy*=0.78; b.pierce=true;
      this.bullets.push(b); sfx('shoot');
      this.burst(this.p.x+Math.cos(a)*26,this.p.y+Math.sin(a)*26,0xffaa00,16,120); this.shake(7,0.10); return;
    }
    if(this.w.type==='single') this.bullets.push(mk(a));
    else if(this.w.type==='double'){ this.bullets.push(mk(a-0.09)); this.bullets.push(mk(a+0.09)); }
    else if(this.w.type==='spread'){ this.bullets.push(mk(a)); this.bullets.push(mk(a-0.18)); this.bullets.push(mk(a+0.18)); }
    else if(this.w.type==='quad'){ this.bullets.push(mk(a-0.20)); this.bullets.push(mk(a-0.07)); this.bullets.push(mk(a+0.07)); this.bullets.push(mk(a+0.20)); }
    sfx('shoot');
    this.burst(this.p.x+Math.cos(a)*26,this.p.y+Math.sin(a)*26,0xffffff,6,55);
    this.muzzleFlashT=0.07;
  }

  getUpgradePool(){
    const self=this;
    let pool=[
      {id:'double',name:'DUAL SHOT',desc:'Fire 2 rounds per shot',color:0x00ffff,ok:()=>self.w.type==='single',apply:(g)=>{g.w.type='double';sfx('upgrade');}},
      {id:'spread',name:'SPREAD',desc:'Three-shot cone pattern',color:0x66ffff,ok:()=>self.w.type!=='spread'&&self.w.type!=='quad',apply:(g)=>{g.w.type='spread';sfx('upgrade');}},
      {id:'quad',name:'QUAD',desc:'Four-shot burst pattern',color:0x22ffee,ok:()=>self.w.type!=='quad',apply:(g)=>{g.w.type='quad';sfx('upgrade');}},
      {id:'rapid',name:'RAPID FIRE',desc:'-18% fire interval',color:0xffaa00,ok:()=>self.w.rate>70,apply:(g)=>{g.w.rate=Math.max(65,(g.w.rate*0.82)|0);sfx('upgrade');}},
      {id:'pierce',name:'PIERCING',desc:'Shots pass through enemies',color:0xff44aa,ok:()=>!self.w.pierce,apply:(g)=>{g.w.pierce=true;sfx('upgrade');}},
      {id:'homing',name:'HOMING',desc:'Bullets curve toward targets',color:0xaa44ff,ok:()=>!self.w.homing,apply:(g)=>{g.w.homing=true;sfx('upgrade');}},
      {id:'mega',name:'MEGA BLAST',desc:'Every 7th shot is explosive',color:0xffaa00,ok:()=>!self.w.mega,apply:(g)=>{g.w.mega=true;sfx('upgrade');}},
      {id:'shield',name:'ENERGY SHIELD',desc:'Gain +50 shield capacity',color:0x4455ff,ok:()=>true,apply:(g)=>{g.p.maxShield=Math.max(g.p.maxShield,50);g.p.shield=Math.min(g.p.maxShield,g.p.shield+50);sfx('upgrade');}},
      {id:'regen',name:'REGEN',desc:'Slowly heal over time',color:0x44ff66,ok:()=>true,apply:(g)=>{g.regenRate+=2.2;sfx('upgrade');}},
      {id:'speed',name:'SPEED UP',desc:'+18% movement speed',color:0xffff44,ok:()=>true,apply:(g)=>{g.p.speed*=1.18;sfx('upgrade');}},
      {id:'hp',name:'MAX HEALTH',desc:'+30 max HP & heal 30',color:0xff5555,ok:()=>true,apply:(g)=>{g.p.maxHp+=30;g.p.hp=Math.min(g.p.maxHp,g.p.hp+30);sfx('upgrade');}},
      {id:'dash',name:'QUICK DASH',desc:'Shorter dash cooldown',color:0x44ffcc,ok:()=>!self._dashUp,apply:(g)=>{g._dashUp=true;g.dashCdDur*=0.70;sfx('upgrade');}},
      
      // New weapons
      {id:'ricochet',name:'RICOCHET',desc:'Bullets bounce off walls',color:0x44ffff,ok:()=>!self.w.ricochet,apply:(g)=>{g.w.ricochet=true;sfx('ricochet');}},
      {id:'shotgun',name:'SHOTGUN BLAST',desc:'8-shot wide spread',color:0xff8844,ok:()=>!self.w.shotgun&&!self.w.laser&&self.w.type==='single',apply:(g)=>{g.w.shotgun=true;sfx('shotgun');}},
      {id:'laser',name:'LASER BEAM',desc:'Hold to fire continuous beam',color:0xff0088,ok:()=>!self.w.laser&&!self.w.shotgun&&self.w.type==='single',apply:(g)=>{g.w.laser=true;sfx('laser');}},
      {id:'bulletSize',name:'BULLET SIZE',desc:'+40% projectile size',color:0xffff44,ok:()=>self.w.bulletSize<2.0,apply:(g)=>{g.w.bulletSize*=1.4;sfx('upgrade');}},
      {id:'teleport',name:'TELEPORT',desc:'Dash becomes instant teleport',color:0xff44ff,ok:()=>!self.p.hasTeleport,apply:(g)=>{g.p.hasTeleport=true;g.dashCdDur*=0.85;sfx('teleport');}},
    ];
    pool=pool.filter(u=>u.ok()); Phaser.Utils.Array.Shuffle(pool); return pool.slice(0,3);
  }

  showUpgradeScreen(){
    this.upgradeMode=true; this.upgradeAnimT=0;
    const choices=this.getUpgradePool(); this.hideUpgradeScreen(false);
    if(!this.upTitle){
      this.upTitle=this.add.text(W/2,120,'UPGRADE',{fontSize:'36px',fontFamily:'"Courier New"',color:'#00ffff'}).setOrigin(0.5).setDepth(32);
      this.upSub=this.add.text(W/2,155,'CHOOSE YOUR POWER',{fontSize:'14px',fontFamily:'"Courier New"',color:'#66ffff'}).setOrigin(0.5).setDepth(32).setAlpha(0.85);
    } else { this.upTitle.setVisible(true); this.upSub.setVisible(true); }

    this.upgradeButtons=choices.map((c,i)=>{
      const cx=190+i*240, cy=H/2+60, w=180, h=240;
      const nT=this.add.text(cx,(cy-120)+98,c.name,{fontSize:'15px',fontFamily:'"Courier New"',color:'#ffffff'}).setOrigin(0.5).setDepth(33).setAlpha(0);
      const dT=this.add.text(cx,(cy-120)+132,c.desc,{fontSize:'12px',fontFamily:'"Courier New"',color:'#aaccff',wordWrap:{width:w-26,useAdvancedWrap:true}}).setOrigin(0.5).setDepth(33).setAlpha(0);
      this.upgradeTexts.push(nT,dT);
      return {x:cx,y:cy,w,h,animDelay:i*0.12,nameT:nT,descT:dT,...c};
    });
  }

  hideUpgradeScreen(clearG=true){
    this.upgradeTexts.forEach(t=>t.destroy()); this.upgradeTexts=[]; this.upgradeButtons=[];
    if(this.upTitle)this.upTitle.setVisible(false); if(this.upSub)this.upSub.setVisible(false);
    if(clearG)this.gUp.clear();
  }

  clickUpgrade(mx,my){
    for(const b of this.upgradeButtons){
      if(mx>=b.x-b.w/2&&mx<=b.x+b.w/2&&my>=b.y-b.h/2&&my<=b.y+b.h/2){
        b.apply(this); 
        this.stats.upgradesTaken++; 
        if(this.stats.upgradesTaken >= 10) unlockAchievement('allUpgrades');
        this.upgradeMode=false; this.hideUpgradeScreen(true); this.nextWave(); return;
      }
    }
  }

  spawnPickup(x,y,forcedType=null){
    let type=forcedType;
    if(!type){ const r=Math.random(); if(r<0.40)type='health'; else if(r<0.58)type='shield'; else if(r<0.73)type='speed'; else if(r<0.88)type='score'; else type='slowmo'; }
    this.pickups.push({x,y,type,life:9.5,a:rand(0,Math.PI*2)});
  }

  collectPickup(p){
    switch(p.type){
      case 'health': this.p.hp=Math.min(this.p.maxHp,this.p.hp+30); break;
      case 'shield': this.p.maxShield=Math.max(this.p.maxShield,50); this.p.shield=Math.min(this.p.maxShield,this.p.shield+25); break;
      case 'speed': this.p.speed*=1.18; this.time.delayedCall(5000,()=>{this.p.speed/=1.18;}); this.showNotif('SPEED BOOST','#ffff44',1.0); break;
      case 'score': this.score+=15*(1+this.combo*0.5)|0; break;
      case 'slowmo': this.slowActive=true; this.slowT=3.5; sfx('slowmo'); this.showNotif('âŸ³  TIME SLOW  âŸ³','#cc88ff',1.5); break;
    }
    sfx('pickup');
    const col=(p.type==='health')?0xff4444:(p.type==='shield')?0x4444ff:(p.type==='speed')?0xffff44:(p.type==='slowmo')?0xcc88ff:0x44ff44;
    this.burst(p.x,p.y,col,7,70);
  }

  burst(x,y,color,count=10,spd=90){
    for(let i=0;i<count;i++){
      const a=rand(0,Math.PI*2), s=rand(spd*0.6,spd*1.4);
      this.particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:rand(0.25,0.55),color,size:rand(1.5,3.5)});
    }
  }

  explodeMega(x,y,dmg=25){
    const r=80+this.wave*4;
    this.enemies.forEach((e)=>{
      const d=dist(x,y,e.x,e.y);
      if(d<r+e.size){ e.hp-=dmg; if(e.hp<=0){const idx=this.enemies.indexOf(e);if(idx>=0)this.killEnemy(e,idx);} else sfx('enemyHit'); }
    });
    this.burst(x,y,0xffaa00,30,150); this.shake(15,0.18);
    if(dist(x,y,this.p.x,this.p.y)<r+14){ this.dmgPlayer(Math.max(3,dmg*0.3|0)); }
  }

  dmgPlayer(amount){
    this.waveDamageTaken += amount;
    
    const ship = SHIPS[this.p.shipIdx];
    if(ship.name === 'TANKS') {
      amount *= 0.75; // 25% damage reduction
    }
    
    if(this.p.invuln>0) return;
    this.combo=0;
    if(this.p.shield>0){ 
      const old=this.p.shield; this.p.shield=Math.max(0,this.p.shield-amount);
      const rem=amount-(old-this.p.shield); if(rem>0)this.p.hp=Math.max(0,this.p.hp-rem);
      sfx('shieldHit'); 
    } else { 
      this.p.hp=Math.max(0,this.p.hp-amount); sfx('hit'); 
    }
    this.p.invuln=0.35; this.shake(8,0.12);
    if(this.p.hp<=0){ this.die(); }
  }

  killEnemy(e,idx){
    if(e.type==='bomber'){
      this.explodeMega(e.x,e.y,18+this.wave*2);
    }
    
    if(e.type==='boss' || e.type==='boss2' || e.type==='boss3'){
      this.bossesDefeated++;
      if(this.bossesDefeated === 1) unlockAchievement('boss1');
    }
    
    this.score+=e.pts; this.combo++; this.comboTimer=this.comboMaxTime;
    if(this.combo>this.stats.peakCombo)this.stats.peakCombo=this.combo;
    if(this.combo === 10) unlockAchievement('combo10');
    
    this.stats.enemiesKilled++;
    trackEnemyKill();
    
    const isBoss=(e.type==='boss'||e.type==='boss2'||e.type==='boss3');
    if(isBoss){ sfx('bossDie'); this.bossKillSlowT=1.2; this.burst(e.x,e.y,e.color,60,220); this.shake(25,0.25); this.spawnPickup(e.x,e.y,'health'); this.spawnPickup(e.x+30,e.y-20,'shield'); } 
    else { sfx('enemyDie'); this.burst(e.x,e.y,e.color,10,100); }
    if(Math.random()<0.22 && !isBoss)this.spawnPickup(e.x,e.y);
    this.enemies.splice(idx,1);
  }

  spawnEnemyBullet(x,y,ang,spd,dmg){
    this.eBullets.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,dmg,life:4.0});
  }

  die(){
    this.gameOver=true; sfx('playerDie'); this.shake(20,0.30);
    lastScore=this.score; lastWave=this.wave; lastStats={...this.stats};
    if(this.score>highScore){ highScore=this.score; }
    savePersistent();
    this.time.delayedCall(2500,()=>{this.scene.start('GameOver');});
  }

  shake(amt,dur){ this.shakeAmt=amt; this.shakeT=dur; }

  pointLineDistance(px,py,x1,y1,x2,y2){
    const A=px-x1, B=py-y1, C=x2-x1, D=y2-y1;
    const dot=A*C+B*D, lenSq=C*C+D*D;
    let param=-1;
    if(lenSq!==0)param=dot/lenSq;
    let xx,yy;
    if(param<0){xx=x1;yy=y1;}
    else if(param>1){xx=x2;yy=y2;}
    else{xx=x1+param*C;yy=y1+param*D;}
    const dx=px-xx, dy=py-yy;
    return Math.sqrt(dx*dx+dy*dy);
  }

  updateLaser(dt){
    if(this.w.laser && this.laserActive){
      this.laserChargeT+=dt;
      if(this.laserChargeT>0.1){
        const a=this.p.angle;
        const laserLength=600;
        const startX=this.p.x+Math.cos(a)*24;
        const startY=this.p.y+Math.sin(a)*24;
        const endX=startX+Math.cos(a)*laserLength;
        const endY=startY+Math.sin(a)*laserLength;
        
        for(const e of this.enemies){
          const distToLine=this.pointLineDistance(e.x,e.y,startX,startY,endX,endY);
          if(distToLine<e.size+10){
            e.hp-=(this.w.dmg*0.5+this.wave)*dt*10;
            if(e.hp<=0){
              const idx=this.enemies.indexOf(e);
              if(idx>=0)this.killEnemy(e,idx);
            }
          }
        }
      }
    }
    
    if(!this.mouseDown && this.laserActive){
      this.laserActive=false;
      this.laserChargeT=0;
    }
  }

  updateGravityWells(dt){
    for(let i=this.gravityWells.length-1;i>=0;i--){
      const gw=this.gravityWells[i];
      gw.life-=dt;
      if(gw.life<=0){ this.gravityWells.splice(i,1); continue; }
      
      for(const e of this.enemies){
        const d=dist(gw.x,gw.y,e.x,e.y);
        if(d<gw.radius){
          const[dx,dy]=norm(gw.x-e.x,gw.y-e.y);
          const strength=gw.strength*(1-d/gw.radius);
          e.x+=dx*strength*dt;
          e.y+=dy*strength*dt;
        }
      }
    }
  }

  updateHealer(e,dt){
    const d=dist(e.x,e.y,this.p.x,this.p.y);
    const [dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
    
    if(d < 140) { e.x-=dx*e.speed*dt; e.y-=dy*e.speed*dt; }
    else if(d > 180) { e.x+=dx*e.speed*0.5*dt; e.y+=dy*e.speed*0.5*dt; }
    
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    e.healT-=dt;
    
    if(e.healT<=0){
      e.healT=2.0;
      for(const other of this.enemies){
        if(other !== e && dist(e.x,e.y,other.x,other.y) < e.healRange && other.hp < other.maxHp){
          const healAmount = 15 + this.wave * 2;
          other.hp = Math.min(other.maxHp, other.hp + healAmount);
          this.burst(other.x, other.y, 0x44ff44, 8, 60);
        }
      }
    }
    
    e.x=clamp(e.x,30,W-30); e.y=clamp(e.y,30,H-30);
  }

  updateSpawner(e,dt){
    const d=dist(e.x,e.y,this.p.x,this.p.y);
    const [dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
    
    if(d < 160) { e.x-=dx*e.speed*dt; e.y-=dy*e.speed*dt; }
    else if(d > 200) { e.x+=dx*e.speed*0.5*dt; e.y+=dy*e.speed*0.5*dt; }
    
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    e.spawnT-=dt;
    
    if(e.spawnT<=0 && e.spawned < e.maxSpawns){
      e.spawnT=4.0;
      e.spawned++;
      
      const angle = rand(0, Math.PI*2);
      const spawnDist = 40;
      const spawn = {
        x: e.x + Math.cos(angle) * spawnDist,
        y: e.y + Math.sin(angle) * spawnDist,
        angle: 0,
        type: 'drone',
        alive: true,
        hp: 15 + this.wave * 3,
        maxHp: 15 + this.wave * 3,
        speed: 100 + this.wave * 3,
        size: 10,
        color: 0xff44ff,
        glow: 0xff66ff,
        pts: 5 + this.wave
      };
      this.enemies.push(spawn);
      this.burst(spawn.x, spawn.y, 0xff44ff, 10, 80);
    }
    
    e.x=clamp(e.x,30,W-30); e.y=clamp(e.y,30,H-30);
  }

  updateBomber(e,dt){
    const[dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
    e.x+=dx*e.speed*dt; e.y+=dy*e.speed*dt;
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+16){
      this.explodeMega(e.x, e.y, 20 + this.wave * 3);
      this.dmgPlayer(15);
      this.enemies.splice(this.enemies.indexOf(e),1);
    }
  }

  updateTeleporter(e,dt){
    const[dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
    e.x+=dx*e.speed*dt; e.y+=dy*e.speed*dt;
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    e.teleportT-=dt;
    if(e.teleportT<=0){
      e.teleportT=2.5;
      this.burst(e.x, e.y, 0x8844ff, 12, 100);
      e.x = rand(50, W-50);
      e.y = rand(50, H-50);
      this.burst(e.x, e.y, 0x8844ff, 12, 100);
    }
  }

  updateKamikaze(e,dt){
    const d=dist(e.x,e.y,this.p.x,this.p.y);
    const speed = d < 150 ? e.chargeSpeed : e.speed;
    const[dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
    e.x+=dx*speed*dt; e.y+=dy*speed*dt;
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+16){
      this.dmgPlayer(18);
      const[px,py]=norm(e.x-this.p.x,e.y-this.p.y); 
      e.x+=px*60; e.y+=py*60;
    }
  }

  updateArtillery(e,dt){
    const d=dist(e.x,e.y,this.p.x,this.p.y);
    const [dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
    
    if(d < e.minRange) { e.x-=dx*e.speed*1.2*dt; e.y-=dy*e.speed*1.2*dt; }
    else if(d > e.minRange + 100) { e.x+=dx*e.speed*0.4*dt; e.y+=dy*e.speed*0.4*dt; }
    
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    e.shootT-=dt;
    
    if(e.shootT<=0){
      e.shootT=1.8 + Math.random();
      const ang=Math.atan2(this.p.y-e.y,this.p.x-e.x);
      this.spawnEnemyBullet(e.x,e.y,ang,180,16);
      this.burst(e.x+Math.cos(ang)*14,e.y+Math.sin(ang)*14,0x6666ff,6,60);
    }
    
    e.x=clamp(e.x,30,W-30); e.y=clamp(e.y,30,H-30);
  }

  updateBoss1(e,dt){
    const hpPct=e.hp/e.maxHp; if(hpPct<0.40)e.phase=2;
    if(e.y<120&&!e._enteredArena){ e.y+=120*dt; if(e.y>=120)e._enteredArena=true; }
    
    e.orbA+=dt*(e.phase===2?0.7:0.5);
    const tx=W/2+Math.cos(e.orbA)*110, ty=H/2+Math.sin(e.orbA)*90;
    const[mx,my]=norm(tx-e.x,ty-e.y); e.x+=mx*e.speed*dt; e.y+=my*e.speed*dt;
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    if(!e.charging){ e.chargeT-=dt; if(e.chargeT<=0){ e.charging=true; e.chargeT=e.chargeI; e.chargeTarget={x:this.p.x,y:this.p.y}; sfx('bossBegin'); }}
    else{ e.chargeT-=dt; if(e.chargeT<=0){ e.charging=false; e.chargeT=e.chargeI; } const[cx,cy]=norm(e.chargeTarget.x-e.x,e.chargeTarget.y-e.y); e.x+=cx*(e.speed*2.8)*dt; e.y+=cy*(e.speed*2.8)*dt; }
    e.shootT-=dt; if(e.shootT<=0){ e.shootT=(e.phase===2?1.0:1.6); e.ringA+=0.5; for(let i=0;i<(e.phase===2?8:6);i++){ const a=(i/(e.phase===2?8:6))*Math.PI*2+e.ringA; this.spawnEnemyBullet(e.x,e.y,a,140,12); } }
  }

  updateBoss2(e,dt){
    const hpPct=e.hp/e.maxHp; if(hpPct<0.40)e.phase=2;
    if(e.y<120&&!e._enteredArena){ e.y+=120*dt; if(e.y>=120)e._enteredArena=true; }
    
    e.orbitalA+=dt*0.8;
    const tx=W/2+Math.cos(e.orbitalA)*120;
    const ty=H/2+Math.sin(e.orbitalA*2)*80;
    const[mx,my]=norm(tx-e.x,ty-e.y); e.x+=mx*e.speed*dt; e.y+=my*e.speed*dt;
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    e.shootT-=dt;
    if(e.shootT<=0){
      e.shootT=e.phase===2?0.8:1.3;
      const spiralCount = e.phase===2?8:5;
      for(let i=0;i<spiralCount;i++){
        const ang = (i/spiralCount)*Math.PI*2 + this.time.now/1000;
        this.spawnEnemyBullet(e.x,e.y,ang,160,7);
      }
    }
  }

  updateBoss3(e,dt){
    const hpPct=e.hp/e.maxHp; if(hpPct<0.40)e.phase=2;
    if(e.y<120&&!e._enteredArena){ e.y+=120*dt; if(e.y>=120)e._enteredArena=true; }
    
    const tx = this.p.x + (Math.random()-0.5)*200;
    const ty = this.p.y + (Math.random()-0.5)*200;
    const[mx,my]=norm(tx-e.x,ty-e.y); e.x+=mx*e.speed*dt; e.y+=my*e.speed*dt;
    e.x=clamp(e.x,60,W-60); e.y=clamp(e.y,60,H-60);
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    e.shootT-=dt;
    if(e.shootT<=0){
      e.shootT=1.0;
      const base=Math.atan2(this.p.y-e.y,this.p.x-e.x);
      this.spawnEnemyBullet(e.x,e.y,base,240,9);
      if(e.phase===2){
        this.spawnEnemyBullet(e.x,e.y,base-0.4,240,9);
        this.spawnEnemyBullet(e.x,e.y,base+0.4,240,9);
      }
    }
    
    e.splitT-=dt;
    if(e.splitT<=0 && e.phase===2){
      e.splitT=8.0;
      for(let i=0;i<4;i++){
        const ang = (i/4)*Math.PI*2;
        const spawn = {
          x: e.x + Math.cos(ang)*50,
          y: e.y + Math.sin(ang)*50,
          angle: 0,
          type: 'scout',
          alive: true,
          hp: 20 + this.wave * 4,
          maxHp: 20 + this.wave * 4,
          speed: 120 + this.wave * 4,
          size: 8,
          color: 0x44ff44,
          glow: 0x66ff66,
          pts: 10 + this.wave
        };
        this.enemies.push(spawn);
      }
      this.burst(e.x, e.y, 0x44ff44, 20, 120);
    }
  }

  updateMiniBoss(e,dt){
    const hpPct=e.hp/e.maxHp;
    if(hpPct<0.5)e.phase=2;
    
    if(e.y<100&&!e._enteredArena){ e.y+=100*dt; if(e.y>=100)e._enteredArena=true; }
    
    e.orbA+=(e.phase===2?0.7:0.5)*dt;
    const rad=70+Math.sin(this.time.now/1000*1.5)*50;
    const tx=W/2+Math.cos(e.orbA)*rad, ty=H/2+Math.sin(e.orbA)*rad;
    const[mx,my]=norm(tx-e.x,ty-e.y); e.x+=mx*e.speed*dt; e.y+=my*e.speed*dt;
    e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
    
    e.shootT-=dt;
    if(e.shootT<=0){
      e.shootT=e.phase===2?0.7:1.2;
      const base=Math.atan2(this.p.y-e.y,this.p.x-e.x);
      if(e.phase===1) {
        this.spawnEnemyBullet(e.x,e.y,base,180,10);
      } else {
        [-0.3,0,0.3].forEach(s=>this.spawnEnemyBullet(e.x,e.y,base+s,200,10));
      }
    }
  }

  update(time,delta){
    if(this.gameOver)return;
    const dt=Math.min(delta/1000,0.033); 
    const slowMult=(this.slowActive||this.bossKillSlowT>0)?0.4:1.0;
    const dtS=dt*slowMult;

    if(this.bossKillSlowT>0){ this.bossKillSlowT-=dt; if(this.bossKillSlowT<0)this.bossKillSlowT=0; }
    if(this.slowT>0){ this.slowT-=dt; if(this.slowT<=0)this.slowActive=false; }
    if(this.notifTimer>0){ this.notifTimer-=dt; if(this.notifTimer<=0&&this.notifText)this.notifText.setAlpha(0); }
    if(this.muzzleFlashT>0)this.muzzleFlashT-=dt;
    if(this.p.invuln>0)this.p.invuln-=dt;
    if(this.p.dashCD>0)this.p.dashCD-=dt;

    // Afterburner timer
    if(this.afterburnerT > 0) {
      this.afterburnerT -= dt;
    }

    // Update laser
    this.updateLaser(dtS);

    // Update gravity wells
    this.updateGravityWells(dtS);

    // Player movement
    let nx=0,ny=0;
    if(this.keys.w.isDown)ny-=1; if(this.keys.s.isDown)ny+=1;
    if(this.keys.a.isDown)nx-=1; if(this.keys.d.isDown)nx+=1;
    if(nx||ny){
      [nx,ny]=norm(nx,ny);
      let speedMult = 1.0;
      if(this.afterburnerT > 0) {
        speedMult = 1.15;
      }
      this.p.x+=nx*this.p.speed*speedMult*dt; 
      this.p.y+=ny*this.p.speed*speedMult*dt;
      this.p.idleT=0;
    } else this.p.idleT+=dt;
    
    this.p.x=clamp(this.p.x,28,W-28); this.p.y=clamp(this.p.y,28,H-28);

    // Dash
    if(this.keys.space.isDown&&!this.p.dashing&&this.p.dashCD<=0){
      if(nx||ny){
        this.p.dashing=true; this.p.dashT=0.16; this.p.dashA=Math.atan2(ny,nx);
        
        const ship = SHIPS[this.p.shipIdx];
        
        if(this.p.hasTeleport) {
          const teleportDist = 120;
          this.p.x += nx * teleportDist;
          this.p.y += ny * teleportDist;
          this.p.x=clamp(this.p.x,28,W-28); 
          this.p.y=clamp(this.p.y,28,H-28);
          this.p.dashCD=this.dashCdDur;
          this.p.invuln=Math.max(this.p.invuln,0.25);
          sfx('teleport');
          this.burst(this.p.x,this.p.y,0xff44ff,20,160);
        } else {
          this.p.dashCD=this.dashCdDur;
          this.p.invuln=Math.max(this.p.invuln,0.20);
          sfx('dash');
          this.burst(this.p.x,this.p.y,SHIPS[this.p.shipIdx].color,12,130);
          
          if(Math.random() < 0.3) {
            this.gravityWells.push({
              x: this.p.x,
              y: this.p.y,
              life: 3.0,
              maxLife: 3.0,
              radius: 100,
              strength: 150
            });
            sfx('gravityWell');
          }
        }
        
        // RAZOR perk: Afterburner
        if(ship.name === 'RAZOR') {
          this.afterburnerT = 2.0;
        }
        
        this.stats.dashesUsed++;
      }
    }
    if(this.p.dashing){
      this.p.dashT-=dt;
      const dashSpd=550;
      this.p.x+=Math.cos(this.p.dashA)*dashSpd*dt;
      this.p.y+=Math.sin(this.p.dashA)*dashSpd*dt;
      this.p.x=clamp(this.p.x,28,W-28); this.p.y=clamp(this.p.y,28,H-28);
      if(this.p.dashT<=0)this.p.dashing=false;
    }

    // Regen
    if(this.regenRate>0 && this.p.hp<this.p.maxHp){
      this.p.hp=Math.min(this.p.maxHp,this.p.hp+this.regenRate*dt);
    }

    // Aiming
    const ptr=this.input.activePointer;
    this.p.angle=Math.atan2(ptr.y-this.p.y,ptr.x-this.p.x);

    // Shooting
    if(this.mouseDown&&!this.upgradeMode&&!this.gameOver){
      if(time-this.lastFired>=this.w.rate){ this.fire(time); this.lastFired=time; }
    }

    // Combo decay
    if(this.comboTimer>0){ this.comboTimer-=dt; if(this.comboTimer<=0)this.combo=0; }

    // Spawn enemies
    if(!this.upgradeMode){
      if(this.spawnQ.length>0){
        this.spawnT+=delta;
        while(this.spawnT>=this.spawnDelay&&this.spawnQ.length>0){
          this.spawnEnemy(this.spawnQ.shift()); this.spawnT-=this.spawnDelay;
        }
      }
      if(this.spawnQ.length===0&&this.enemies.length===0&&!this.waveComplete){
        this.waveComplete=true; this.waveEndT=1.2;
      }
      if(this.waveComplete){
        this.waveEndT-=dt; if(this.waveEndT<=0){ this.showUpgradeScreen(); }
      }
    }

    // Update enemies
    for(let i=this.enemies.length-1;i>=0;i--){
      const e=this.enemies[i];
      
      if(e.type==='healer'){ this.updateHealer(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(8); continue; }
      if(e.type==='spawner'){ this.updateSpawner(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(10); continue; }
      if(e.type==='bomber'){ this.updateBomber(e,dtS); continue; }
      if(e.type==='teleporter'){ this.updateTeleporter(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(10); continue; }
      if(e.type==='kamikaze'){ this.updateKamikaze(e,dtS); continue; }
      if(e.type==='artillery'){ this.updateArtillery(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(8); continue; }
      
      if(e.type==='boss') { this.updateBoss1(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(15); continue; }
      if(e.type==='boss2') { this.updateBoss2(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(15); continue; }
      if(e.type==='boss3') { this.updateBoss3(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(15); continue; }
      if(e.type==='miniboss') { this.updateMiniBoss(e,dtS); if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14)this.dmgPlayer(12); continue; }
      
      // Default enemy behavior
      if(e.type==='sniper'){
        const d=dist(e.x,e.y,this.p.x,this.p.y);
        const[dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
        if(d<e.minRange){ e.x-=dx*e.speed*1.5*dtS; e.y-=dy*e.speed*1.5*dtS; }
        else if(d>e.minRange+80){ e.x+=dx*e.speed*0.6*dtS; e.y+=dy*e.speed*0.6*dtS; }
        e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
        e.shootT-=dtS;
        if(e.shootT<=0&&!e.charging){
          e.charging=true; e.chargeT=0; e.chargeTarget={x:this.p.x,y:this.p.y};
          this.sniperWarnings.push({x:this.p.x,y:this.p.y,t:0.6,enemy:e});
        }
        if(e.charging){
          e.chargeT+=dtS;
          if(e.chargeT>=0.6){
            e.charging=false; e.shootT=2.0;
            const ang=Math.atan2(e.chargeTarget.y-e.y,e.chargeTarget.x-e.x);
            this.spawnEnemyBullet(e.x,e.y,ang,280,18);
          }
        }
      } else if(e.type==='shieldE'){
        const[dx,dy]=norm(this.p.x-e.x,this.p.y-e.y); e.x+=dx*e.speed*dtS; e.y+=dy*e.speed*dtS;
        e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x); e.shieldA+=dtS*2.0;
      } else if(e.type==='swarm'){
        const d=dist(e.x,e.y,this.p.x,this.p.y);
        let [dx,dy]=norm(this.p.x-e.x,this.p.y-e.y);
        if(d<100){ dx*=-1; dy*=-1; }
        e.x+=dx*e.speed*dtS; e.y+=dy*e.speed*dtS;
        e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
      } else {
        const[dx,dy]=norm(this.p.x-e.x,this.p.y-e.y); e.x+=dx*e.speed*dtS; e.y+=dy*e.speed*dtS;
        e.angle=Math.atan2(this.p.y-e.y,this.p.x-e.x);
      }
      
      if(dist(e.x,e.y,this.p.x,this.p.y)<e.size+14){ this.dmgPlayer(e.type==='tank'?12:e.type==='swarm'?8:e.type==='scout'?6:10); }
    }

    // Update bullets
    for(let i=this.bullets.length-1;i>=0;i--){
      const b=this.bullets[i];
      b.life-=dtS; 
      if(b.life<=0){ this.bullets.splice(i,1); continue; }
      
      // Homing
      if(b.homing&&this.enemies.length>0){
        let best=null,bd=1e9;
        for(const e of this.enemies){ const d=dist2(b.x,b.y,e.x,e.y); if(d<bd){bd=d;best=e;} }
        if(best){
          const[hx,hy]=norm(best.x-b.x,best.y-b.y);
          b.vx+=hx*300*dtS; b.vy+=hy*300*dtS; // Enhanced homing
          const sp=Math.sqrt(b.vx*b.vx+b.vy*b.vy)||1, tSp=this.w.spd+this.wave*5;
          b.vx=(b.vx/sp)*tSp; b.vy=(b.vy/sp)*tSp; b.angle=Math.atan2(b.vy,b.vx);
        }
      }
      
      b.x+=b.vx*dtS; b.y+=b.vy*dtS;
      
      // Ricochet
      if(b.ricochet && b.ricochetsLeft > 0) {
        if(b.x < 10 || b.x > W-10) {
          b.vx *= -1;
          b.ricochetsLeft--;
          b.x = clamp(b.x, 10, W-10);
          sfx('ricochet');
        }
        if(b.y < 10 || b.y > H-10) {
          b.vy *= -1;
          b.ricochetsLeft--;
          b.y = clamp(b.y, 10, H-10);
          sfx('ricochet');
        }
      }
      
      if(b.x<-20||b.x>W+20||b.y<-20||b.y>H+20){ this.bullets.splice(i,1); continue; }
      b.trail.push({x:b.x,y:b.y}); if(b.trail.length>5)b.trail.shift();
      
      // Collisions
      let hit=false;
      for(let j=this.enemies.length-1;j>=0;j--){
        const e=this.enemies[j];
        const r=e.size+(b.mega?10:(6*b.size));
        if(dist2(b.x,b.y,e.x,e.y)<r*r){
          e.hp-=b.dmg;
          if(e.hp<=0)this.killEnemy(e,j); else sfx('enemyHit');
          if(b.mega){ this.explodeMega(b.x,b.y,b.dmg*0.8); this.bullets.splice(i,1); hit=true; break; }
          if(!b.pierce){ this.bullets.splice(i,1); hit=true; break; }
        }
      }
    }

    // Update enemy bullets
    for(let i=this.eBullets.length-1;i>=0;i--){
      const eb=this.eBullets[i];
      eb.life-=dtS; if(eb.life<=0){ this.eBullets.splice(i,1); continue; }
      eb.x+=eb.vx*dtS; eb.y+=eb.vy*dtS;
      if(eb.x<-30||eb.x>W+30||eb.y<-30||eb.y>H+30){ this.eBullets.splice(i,1); continue; }
      if(dist(eb.x,eb.y,this.p.x,this.p.y)<18){ this.dmgPlayer(eb.dmg); this.eBullets.splice(i,1); }
    }

    // Update sniper warnings
    for(let i=this.sniperWarnings.length-1;i>=0;i--){
      const sw=this.sniperWarnings[i]; sw.t-=dtS;
      if(sw.t<=0)this.sniperWarnings.splice(i,1);
    }

    // Update particles
    for(let i=this.particles.length-1;i>=0;i--){
      const p=this.particles[i]; p.life-=dt;
      if(p.life<=0){ this.particles.splice(i,1); continue; }
      p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=180*dt;
    }

    // Update pickups
    for(let i=this.pickups.length-1;i>=0;i--){
      const p=this.pickups[i]; p.life-=dt; p.a+=dt*2.5;
      if(p.life<=0){ this.pickups.splice(i,1); continue; }
      if(dist(p.x,p.y,this.p.x,this.p.y)<28){ this.collectPickup(p); this.pickups.splice(i,1); }
    }

    // Camera shake
    if(this.shakeT>0){ this.shakeT-=dt; this.gridOff=rand(-this.shakeAmt,this.shakeAmt); } else this.gridOff=0;

    // Draw
    this.draw();
  }

  draw(){
    const t=this.time.now/1000;
    this.gBg.clear(); this.gVig.clear(); this.gPk.clear(); this.gEn.clear(); this.gBu.clear(); this.gPa.clear(); this.gPl.clear(); this.gHu.clear(); this.gSlow.clear();

    // Grid
    this.gBg.lineStyle(1,0x00ffff,(this.slowActive||this.bossKillSlowT>0)?0.35:0.15);
    for(let x=0;x<=W;x+=40){ this.gBg.lineTo(x+this.gridOff,0); this.gBg.lineTo(x+this.gridOff,H); this.gBg.moveTo(x+40+this.gridOff,0); }
    for(let y=0;y<=H;y+=40){ this.gBg.moveTo(0,y+this.gridOff); this.gBg.lineTo(W,y+this.gridOff); }
    this.gBg.strokePath();

    // Vignette
    const vr=this.add.graphics().setDepth(1);
    vr.fillGradientStyle(0x000000,0x000000,0x000000,0x000000,0.0,0.0,0.6,0.6);
    vr.fillRect(0,0,W,80); vr.fillRect(0,H-80,W,80);
    vr.fillRect(0,0,80,H); vr.fillRect(W-80,0,80,H);

    // Gravity wells
    for(const gw of this.gravityWells){
      const alpha = gw.life / gw.maxLife;
      this.gPk.lineStyle(2, 0xaa44ff, alpha * 0.6);
      this.gPk.strokeCircle(gw.x, gw.y, gw.radius);
      this.gPk.fillStyle(0xaa44ff, alpha * 0.15);
      this.gPk.fillCircle(gw.x, gw.y, gw.radius);
    }

    // Pickups
    for(const p of this.pickups){
      const s=12, a=p.a, col=(p.type==='health')?0xff4444:(p.type==='shield')?0x4444ff:(p.type==='speed')?0xffff44:(p.type==='slowmo')?0xcc88ff:0x44ff44;
      this.gPk.fillStyle(col,0.85); this.gPk.lineStyle(2,col,0.9);
      this.gPk.beginPath();
      for(let i=0;i<4;i++){ const ang=a+(i/4)*Math.PI*2; this.gPk.lineTo(p.x+Math.cos(ang)*s,p.y+Math.sin(ang)*s); }
      this.gPk.closePath(); this.gPk.fillPath(); this.gPk.strokePath();
    }

    // Enemies
    for(const e of this.enemies){
      const hpPct=e.hp/e.maxHp;
      
      // Boss types
      if(e.type==='boss' || e.type==='boss2' || e.type==='boss3' || e.type==='miniboss'){
        this.gEn.fillStyle(e.color,0.75);
        this.gEn.beginPath(); this.gEn.arc(e.x,e.y,e.size,0,Math.PI*2); this.gEn.fillPath();
        this.gEn.lineStyle(3,e.glow,0.9); this.gEn.strokePath();
        this.gEn.lineStyle(2,0xffffff,0.4+Math.sin(t*3)*0.2);
        this.gEn.strokeCircle(e.x,e.y,e.size-4);
        
        // Boss HP bar
        const barW=e.size*2.2, barH=6, barY=e.y+e.size+18;
        this.gEn.fillStyle(0x220000,0.7); this.gEn.fillRect(e.x-barW/2,barY,barW,barH);
        this.gEn.fillStyle(0xff0000,0.9); this.gEn.fillRect(e.x-barW/2,barY,barW*hpPct,barH);
      }
      // New enemy types
      else if(e.type==='healer'){
        this.gEn.fillStyle(e.color,0.8); 
        this.gEn.beginPath(); 
        this.gEn.arc(e.x,e.y,e.size,0,Math.PI*2); 
        this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,0.7); 
        this.gEn.strokePath();
        this.gEn.fillStyle(0xffffff,0.9);
        this.gEn.fillRect(e.x-6,e.y-2,12,4);
        this.gEn.fillRect(e.x-2,e.y-6,4,12);
      }
      else if(e.type==='spawner'){
        this.gEn.fillStyle(e.color,0.75); 
        this.gEn.beginPath();
        for(let i=0;i<5;i++){
          const a=(i/5)*Math.PI*2+t;
          this.gEn.lineTo(e.x+Math.cos(a)*e.size,e.y+Math.sin(a)*e.size);
        }
        this.gEn.closePath(); 
        this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,0.8); 
        this.gEn.strokePath();
      }
      else if(e.type==='bomber'){
        this.gEn.fillStyle(e.color,0.85);
        this.gEn.beginPath();
        this.gEn.arc(e.x,e.y,e.size,0,Math.PI*2);
        this.gEn.fillPath();
        this.gEn.lineStyle(2,0xff0000,0.6+Math.sin(t*6)*0.3);
        this.gEn.strokePath();
        this.gEn.fillStyle(0xff0000,0.9);
        this.gEn.fillRect(e.x-1.5,e.y-6,3,10);
        this.gEn.fillRect(e.x-1.5,e.y+4,3,3);
      }
      else if(e.type==='teleporter'){
        const fade=Math.sin(t*4)*0.3+0.7;
        this.gEn.fillStyle(e.color,fade*0.8);
        this.gEn.beginPath();
        this.gEn.arc(e.x,e.y,e.size,0,Math.PI*2);
        this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,fade*0.9);
        this.gEn.strokePath();
      }
      else if(e.type==='kamikaze'){
        const a=e.angle;
        this.gEn.fillStyle(e.color,0.9);
        this.gEn.beginPath();
        this.gEn.moveTo(e.x+Math.cos(a)*e.size*1.5,e.y+Math.sin(a)*e.size*1.5);
        this.gEn.lineTo(e.x+Math.cos(a+2.0)*e.size*0.6,e.y+Math.sin(a+2.0)*e.size*0.6);
        this.gEn.lineTo(e.x+Math.cos(a-2.0)*e.size*0.6,e.y+Math.sin(a-2.0)*e.size*0.6);
        this.gEn.closePath();
        this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,0.9);
        this.gEn.strokePath();
      }
      else if(e.type==='artillery'){
        this.gEn.fillStyle(e.color,0.8);
        this.gEn.beginPath();
        for(let i=0;i<4;i++){
          const a=(i/4)*Math.PI*2+t*0.5;
          this.gEn.lineTo(e.x+Math.cos(a)*e.size,e.y+Math.sin(a)*e.size);
        }
        this.gEn.closePath();
        this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,0.75);
        this.gEn.strokePath();
      }
      // Standard enemy types
      else if(e.type==='shieldE'){
        this.gEn.fillStyle(e.color,0.7); this.gEn.beginPath(); this.gEn.arc(e.x,e.y,e.size,0,Math.PI*2); this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,0.75); this.gEn.strokePath();
        this.gEn.lineStyle(3,0x33ccff,0.6+Math.sin(t*4)*0.2);
        this.gEn.beginPath();
        const sa=e.shieldA, arc=Math.PI*0.7;
        this.gEn.arc(e.x,e.y,e.size+6,sa,sa+arc);
        this.gEn.strokePath();
        this.gEn.beginPath();
        this.gEn.arc(e.x,e.y,e.size+6,sa+Math.PI,sa+Math.PI+arc);
        this.gEn.strokePath();
      } else {
        this.gEn.fillStyle(e.color,0.75); this.gEn.beginPath(); this.gEn.arc(e.x,e.y,e.size,0,Math.PI*2); this.gEn.fillPath();
        this.gEn.lineStyle(2,e.glow,0.8); this.gEn.strokePath();
      }
    }

    // Sniper warnings
    for(const sw of this.sniperWarnings){
      const a=1.0-sw.t/0.6;
      this.gEn.lineStyle(2,0xff0000,a*0.8);
      this.gEn.strokeCircle(sw.x,sw.y,30+a*20);
    }

    // Bullets
    for(const b of this.bullets){
      if(b.mega){
        this.gBu.fillStyle(0xffaa00,0.85); this.gBu.beginPath(); this.gBu.arc(b.x,b.y,10,0,Math.PI*2); this.gBu.fillPath();
        this.gBu.lineStyle(2,0xffff00,0.9); this.gBu.strokePath();
      } else {
        const size = 6 * b.size;
        this.gBu.fillStyle(b.homing?0xaa44ff:b.pierce?0xff44aa:0x00ffff,0.85);
        this.gBu.beginPath(); this.gBu.arc(b.x,b.y,size,0,Math.PI*2); this.gBu.fillPath();
        if(b.trail.length>1){
          this.gBu.lineStyle(size*0.8,b.homing?0xaa44ff:b.pierce?0xff44aa:0x00ffff,0.3);
          this.gBu.beginPath(); this.gBu.moveTo(b.trail[0].x,b.trail[0].y);
          for(const tr of b.trail)this.gBu.lineTo(tr.x,tr.y);
          this.gBu.strokePath();
        }
      }
    }

    // Enemy bullets
    for(const eb of this.eBullets){
      this.gBu.fillStyle(0xff3333,0.85); this.gBu.beginPath(); this.gBu.arc(eb.x,eb.y,5,0,Math.PI*2); this.gBu.fillPath();
      this.gBu.lineStyle(1,0xff6666,0.7); this.gBu.strokePath();
    }

    // Laser beam
    if(this.w.laser && this.laserActive && this.laserChargeT > 0.1){
      const a=this.p.angle;
      const laserLength=600;
      const startX=this.p.x+Math.cos(a)*24;
      const startY=this.p.y+Math.sin(a)*24;
      const endX=startX+Math.cos(a)*laserLength;
      const endY=startY+Math.sin(a)*laserLength;
      
      this.gBu.lineStyle(8, 0xff0088, 0.3);
      this.gBu.beginPath();
      this.gBu.moveTo(startX, startY);
      this.gBu.lineTo(endX, endY);
      this.gBu.strokePath();
      
      this.gBu.lineStyle(3, 0xff44ff, 0.9);
      this.gBu.beginPath();
      this.gBu.moveTo(startX, startY);
      this.gBu.lineTo(endX, endY);
      this.gBu.strokePath();
    }

    // Particles
    for(const p of this.particles){
      const a=Math.min(1,p.life*3);
      this.gPa.fillStyle(p.color,a*0.8);
      this.gPa.fillCircle(p.x,p.y,p.size);
    }

    // Player
    const flash=(this.p.invuln>0&&Math.floor(t*20)%2===0);
    if(!flash){
      drawShipInGame(this.gPl, SHIPS[this.p.shipIdx].name, this.p.x, this.p.y, this.p.angle, SHIPS[this.p.shipIdx].color, this.p.upgradeStage);
      
      if(this.muzzleFlashT>0){
        const fa=this.p.angle;
        this.gPl.fillStyle(0xffffff,this.muzzleFlashT/0.07);
        this.gPl.beginPath();
        this.gPl.arc(this.p.x+Math.cos(fa)*28,this.p.y+Math.sin(fa)*28,6,0,Math.PI*2);
        this.gPl.fillPath();
      }
    }

    // HUD
    this.tScore.setText(`SCORE: ${this.score}`);
    this.tWave.setText(`WAVE: ${this.wave}`);
    
    let hpCol='#ff4444';
    if(this.p.hp/this.p.maxHp>0.6)hpCol='#44ff44'; else if(this.p.hp/this.p.maxHp>0.3)hpCol='#ffaa00';
    this.tHp.setText(`HP: ${this.p.hp|0}/${this.p.maxHp|0}  SHIELD: ${this.p.shield|0}`).setColor(hpCol);
    this.tEnemyCount.setText(`ENEMIES: ${this.enemies.length}`);

    // Combo
    if(this.combo>1){
      this.comboText.setText(`${this.combo}x COMBO`).setAlpha(Math.min(1,this.comboTimer/this.comboMaxTime));
    } else this.comboText.setAlpha(0);

    // HP bar
    const barW=200,barH=16,barX=(W-barW)/2,barY=H-48;
    this.gHu.fillStyle(0x220000,0.7); this.gHu.fillRect(barX,barY,barW,barH);
    this.gHu.fillStyle(Phaser.Display.Color.HexStringToColor(hpCol).color,0.9);
    this.gHu.fillRect(barX,barY,barW*(this.p.hp/this.p.maxHp),barH);
    this.gHu.lineStyle(2,0xffffff,0.5); this.gHu.strokeRect(barX,barY,barW,barH);

    // Shield bar
    if(this.p.maxShield>0){
      const shBarY=barY-20;
      this.gHu.fillStyle(0x000022,0.7); this.gHu.fillRect(barX,shBarY,barW,10);
      this.gHu.fillStyle(0x4444ff,0.9);
      this.gHu.fillRect(barX,shBarY,barW*(this.p.shield/this.p.maxShield),10);
      this.gHu.lineStyle(1,0x6666ff,0.6); this.gHu.strokeRect(barX,shBarY,barW,10);
    }

    // Dash CD
    const cdBarW=100,cdBarH=6,cdX=16,cdY=H-55;
    this.gHu.fillStyle(0x222222,0.6); this.gHu.fillRect(cdX,cdY,cdBarW,cdBarH);
    const cdPct=Math.max(0,1-(this.p.dashCD/this.dashCdDur));
    this.gHu.fillStyle(0x44ffcc,0.9); this.gHu.fillRect(cdX,cdY,cdBarW*cdPct,cdBarH);
    this.gHu.lineStyle(1,0x66ffee,0.5); this.gHu.strokeRect(cdX,cdY,cdBarW,cdBarH);

    // Slow-mo overlay
    if(this.slowActive||this.bossKillSlowT>0){
      this.gSlow.fillStyle(0x8844ff,0.08);
      this.gSlow.fillRect(0,0,W,H);
    }

    // Upgrade screen
    if(this.upgradeMode){
      this.upgradeAnimT+=0.016;
      this.gUp.clear();
      this.gUp.fillStyle(0x000000,0.75);
      this.gUp.fillRect(0,0,W,H);
      
      for(const ub of this.upgradeButtons){
        const shown=this.upgradeAnimT>ub.animDelay;
        if(!shown)continue;
        const animP=Math.min(1,(this.upgradeAnimT-ub.animDelay)/0.25);
        const tx=ub.x, ty=ub.y-120+(1-animP)*30, a=animP;
        
        const isHover=(this.input.activePointer.x>=ub.x-ub.w/2&&this.input.activePointer.x<=ub.x+ub.w/2&&this.input.activePointer.y>=ub.y-ub.h/2&&this.input.activePointer.y<=ub.y+ub.h/2);
        const sc=isHover?1.05:1.0;
        
        this.gUp.fillStyle(0x0a0a2a,a*0.85);
        this.gUp.fillRect(ub.x-ub.w/2*sc,ub.y-ub.h/2*sc,ub.w*sc,ub.h*sc);
        this.gUp.lineStyle(3,ub.color,a*(isHover?1.0:0.7));
        this.gUp.strokeRect(ub.x-ub.w/2*sc,ub.y-ub.h/2*sc,ub.w*sc,ub.h*sc);
        
        this.gUp.fillStyle(ub.color,a*0.15);
        this.gUp.fillRect(ub.x-ub.w/2*sc,ub.y-ub.h/2*sc,ub.w*sc,40);
        
        ub.nameT.setPosition(tx,ty+98).setAlpha(a);
        ub.descT.setPosition(tx,ty+132).setAlpha(a*0.85);
      }
    }
  }
}

// ============================================================
// GAME OVER SCENE
// ============================================================
class GameOverScene extends Phaser.Scene {
  constructor(){ super('GameOver'); }

  create(){
    this.cameras.main.setBackgroundColor('#000000');
    
    this.add.text(W/2,120,'GAME OVER',{fontSize:'56px',fontFamily:'"Courier New"',color:'#ff4444'}).setOrigin(0.5);
    
    this.add.text(W/2,220,'SCORE',{fontSize:'16px',fontFamily:'"Courier New"',color:'#66ffff'}).setOrigin(0.5);
    this.add.text(W/2,250,`${lastScore}`,{fontSize:'48px',fontFamily:'"Courier New"',color:'#00ffff'}).setOrigin(0.5);
    
    this.add.text(W/2,320,'WAVE REACHED',{fontSize:'16px',fontFamily:'"Courier New"',color:'#66ffff'}).setOrigin(0.5);
    this.add.text(W/2,350,`${lastWave}`,{fontSize:'36px',fontFamily:'"Courier New"',color:'#ffaa00'}).setOrigin(0.5);
    
    this.add.text(W/2,410,'STATS',{fontSize:'18px',fontFamily:'"Courier New"',color:'#ffffff'}).setOrigin(0.5);
    
    let y=450;
    const stats=[
      `Enemies Killed: ${lastStats.enemiesKilled||0}`,
      `Upgrades Taken: ${lastStats.upgradesTaken||0}`,
      `Dashes Used: ${lastStats.dashesUsed||0}`,
      `Peak Combo: ${lastStats.peakCombo||0}x`
    ];
    stats.forEach(s=>{
      this.add.text(W/2,y,s,{fontSize:'14px',fontFamily:'"Courier New"',color:'#aaccff'}).setOrigin(0.5);
      y+=26;
    });
    
    const retryBtn=this.add.text(W/2-90,H-80,'â†» RETRY',{fontSize:'18px',fontFamily:'"Courier New"',color:'#00ff00'}).setOrigin(0.5).setInteractive();
    retryBtn.on('pointerdown',()=>this.scene.start('Game'));
    
    const menuBtn=this.add.text(W/2+90,H-80,'â† MENU',{fontSize:'18px',fontFamily:'"Courier New"',color:'#00ffff'}).setOrigin(0.5).setInteractive();
    menuBtn.on('pointerdown',()=>this.scene.start('Menu'));
  }
}

// ============================================================
// GAME CONFIG
// ============================================================
const config = {
  type: Phaser.AUTO,
  width: W,
  height: H,
  parent: 'game-container',
  backgroundColor: '#000000',
  scene: [MenuScene, AchievementsScene, GameScene, GameOverScene]
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
